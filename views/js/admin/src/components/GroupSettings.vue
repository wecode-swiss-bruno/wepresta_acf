<script setup lang="ts">
import { computed, ref, watch } from 'vue'
import { useBuilderStore } from '@/stores/builderStore'
import { useTranslations } from '@/composables/useTranslations'
import { useApi } from '@/composables/useApi'
import PsSwitch from '@/components/ui/PsSwitch.vue'

const emit = defineEmits<{
  'next-step': []
}>()

const store = useBuilderStore()
const { t } = useTranslations()
const api = useApi()

// Track if slug was manually edited by user
const slugManuallyEdited = ref<boolean>(false)
// Track the last auto-generated slug to detect manual changes
const lastAutoGeneratedSlug = ref<string>('')

// Auto-save group when proceeding to next step if not saved yet
async function handleNextStep(): Promise<void> {
  // If group is not saved yet, save it first
  if (!isGroupSaved.value && canProceedToNextStep.value) {
    try {
      await store.saveGroup()
    } catch (error) {
      console.error('Failed to save group:', error)
      return
    }
  }

  // Proceed to next step
  emit('next-step')
}

const group = computed(() => store.currentGroup)

// Reset slug tracking when group changes
watch(() => group.value, (newGroup) => {
  if (newGroup) {
    // Reset tracking for new groups or when group changes
    slugManuallyEdited.value = false
    lastAutoGeneratedSlug.value = ''
    
    // If group has a slug, check if it matches auto-generated from title
    if (newGroup.slug && newGroup.title) {
      // Generate slug from title to compare
      api.slugify(newGroup.title).then((autoSlug) => {
        if (newGroup.slug === autoSlug) {
          // Slug matches auto-generated, so it's not manually edited
          lastAutoGeneratedSlug.value = autoSlug
          slugManuallyEdited.value = false
        } else {
          // Slug differs, consider it manually edited
          slugManuallyEdited.value = true
        }
      }).catch(() => {
        // On error, assume it might be manually edited
        slugManuallyEdited.value = true
      })
    }
  } else {
    slugManuallyEdited.value = false
    lastAutoGeneratedSlug.value = ''
  }
}, { immediate: true })

// Check if group has valid content to proceed
const canProceedToNextStep = computed(() => {
  return group.value &&
         group.value.title?.trim() &&
         group.value.slug?.trim()
})

// Check if group is saved (has ID)
const isGroupSaved = computed(() => {
  return group.value && group.value.id !== undefined && group.value.id !== null
})


// Computed property for slug field readonly state
const slugReadonly = computed(() => {
  return !slugManuallyEdited.value
})

// Mark group as having unsaved changes when title/slug change
function onGroupChange(): void {
  store.markAsUnsaved()
}

// Auto-generate slug from title (only if slug hasn't been manually edited)
const slugTimeout = ref<number | null>(null)
const isGeneratingSlug = ref<boolean>(false)

async function onTitleChange(): Promise<void> {
  if (!group.value) return

  // Ne pas auto-générer si le slug a été modifié manuellement
  if (slugManuallyEdited.value) {
    onGroupChange()
    return
  }

  // Always auto-generate on title change (not just for empty slugs)
  // Clear existing timeout
  if (slugTimeout.value) {
    clearTimeout(slugTimeout.value)
  }

  // Set flag to prevent interference
  isGeneratingSlug.value = true

  slugTimeout.value = window.setTimeout(async () => {
    if (!group.value) {
      isGeneratingSlug.value = false
      return
    }

    // Double check: if slug was manually edited during timeout, don't update
    if (slugManuallyEdited.value) {
      isGeneratingSlug.value = false
      return
    }

    // Only update if title still exists
    if (group.value.title) {
      try {
        const newSlug = await api.slugify(group.value.title)
        // Only update if slug hasn't been manually changed
        if (!slugManuallyEdited.value && group.value) {
          group.value.slug = newSlug
          lastAutoGeneratedSlug.value = newSlug
          // Mark as having unsaved changes
          onGroupChange()
        }
      } catch (error) {
        console.error('Error generating slug:', error)
      }
    }

    isGeneratingSlug.value = false
  }, 300) // Responsive UX
}

// Track manual slug edits
function onSlugChange(): void {
  if (!group.value) return
  
  // If slug is different from last auto-generated, mark as manually edited
  if (group.value.slug !== lastAutoGeneratedSlug.value) {
    slugManuallyEdited.value = true
  }
  
  onGroupChange()
}

// Method to handle slug field focus - allow manual editing
function onSlugFocus(): void {
  if (!slugManuallyEdited.value) {
    slugManuallyEdited.value = true
  }
}
</script>

<template>
  <div v-if="group" class="acfps-group-settings">
    <div class="acfps-form-section">
      <h4>{{ t('general') }}</h4>

      <div class="form-group">
        <label class="form-control-label">{{ t('groupTitle') }} *</label>
        <input
          v-model="group.title"
          type="text"
          class="form-control"
          @input="onTitleChange"
        >
        <small class="form-text text-muted">
          A descriptive name for this field group that will be displayed in the admin interface.
        </small>
      </div>

      <div class="form-group">
        <label class="form-control-label">{{ t('groupSlug') }} *</label>
        <input
          v-model="group.slug"
          type="text"
          class="form-control"
          pattern="[a-z0-9_\-]+"
          :readonly="slugReadonly"
          :class="{ 'bg-light': slugReadonly }"
          @input="onSlugChange"
          @focus="onSlugFocus"
        >
        <small class="form-text text-muted">
          <span v-if="slugReadonly">Auto-generated from title. Click to edit manually.</span>
          <span v-else>Unique identifier used in templates: <code>acf('{{ group.slug || 'slug' }}', 'field_name')</code></span>
        </small>
      </div>

      <div class="form-group">
        <label class="form-control-label">{{ t('groupDescription') }}</label>
        <textarea
          v-model="group.description"
          class="form-control"
          rows="3"
        />
        <small class="form-text text-muted">
          Optional description to help administrators understand the purpose of this field group.
        </small>
      </div>
    </div>

    <div class="acfps-form-section">
      <h4>{{ t('options') }}</h4>

      <div class="form-group">
        <label class="form-control-label">{{ t('active') }}</label>
        <PsSwitch
          v-model="group.active"
          id="group-active"
        />
        <small class="form-text text-muted">
          Inactive groups are hidden in the product form.
        </small>
      </div>

    </div>

    <!-- Step Navigation -->
    <div class="acfps-step-navigation">
      <div></div> <!-- Spacer -->
      <button
        class="btn btn-primary"
        :disabled="!canProceedToNextStep || store.saving"
        @click="handleNextStep"
      >
        <span v-if="store.saving">{{ t('saving') }}</span>
        <span v-else>Next: {{ t('location') }}</span>
        <span v-if="!store.saving" class="material-icons">arrow_forward</span>
      </button>
    </div>
  </div>
</template>

<style scoped>
.acfps-group-settings {
  padding: 0;
}


.acfps-step-navigation {
  display: flex;
  justify-content: space-between;
  padding: 1.5rem;
  border-top: 1px solid #dee2e6;
  margin-top: 2rem;
  background: #f8f9fa;
}

.acfps-step-navigation .btn {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.acfps-step-navigation .btn .material-icons {
  font-size: 18px;
}
</style>

