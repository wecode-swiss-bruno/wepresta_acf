<script setup lang="ts">
import { ref, computed, watch, nextTick, onBeforeUnmount } from 'vue'
import { useBuilderStore } from '@/stores/builderStore'
import { useTranslations } from '@/composables/useTranslations'
import { useApi } from '@/composables/useApi'
import type { AcfField } from '@/types'
import TextFieldConfig from '@/components/fields/TextFieldConfig.vue'
import TextareaFieldConfig from '@/components/fields/TextareaFieldConfig.vue'
import NumberFieldConfig from '@/components/fields/NumberFieldConfig.vue'
import EmailFieldConfig from '@/components/fields/EmailFieldConfig.vue'
import UrlFieldConfig from '@/components/fields/UrlFieldConfig.vue'
import SelectFieldConfig from '@/components/fields/SelectFieldConfig.vue'
import CheckboxFieldConfig from '@/components/fields/CheckboxFieldConfig.vue'
import RadioFieldConfig from '@/components/fields/RadioFieldConfig.vue'
import BooleanFieldConfig from '@/components/fields/BooleanFieldConfig.vue'
import DateFieldConfig from '@/components/fields/DateFieldConfig.vue'
import TimeFieldConfig from '@/components/fields/TimeFieldConfig.vue'
import DatetimeFieldConfig from '@/components/fields/DatetimeFieldConfig.vue'
import ColorFieldConfig from '@/components/fields/ColorFieldConfig.vue'
import RichTextFieldConfig from '@/components/fields/RichTextFieldConfig.vue'
import FileFieldConfig from '@/components/fields/FileFieldConfig.vue'
import ImageFieldConfig from '@/components/fields/ImageFieldConfig.vue'
import VideoFieldConfig from '@/components/fields/VideoFieldConfig.vue'
import GalleryFieldConfig from '@/components/fields/GalleryFieldConfig.vue'
import FilesFieldConfig from '@/components/fields/FilesFieldConfig.vue'
import RelationFieldConfig from '@/components/fields/RelationFieldConfig.vue'
import ListFieldConfig from '@/components/fields/ListFieldConfig.vue'
import RepeaterFieldConfig from '@/components/fields/RepeaterFieldConfig.vue'
import PsSwitch from '@/components/ui/PsSwitch.vue'

const store = useBuilderStore()
const { t } = useTranslations()
const api = useApi()

const activeTab = ref<'general' | 'validation' | 'presentation'>('general')

// Local copy for editing
const localField = ref<AcfField | null>(null)

// Track if slug was manually edited by user
const slugManuallyEdited = ref<boolean>(false)
// Track the last auto-generated slug to detect manual changes
const lastAutoGeneratedSlug = ref<string>('')

// Sync with store selection
watch(() => store.selectedField, (newField) => {
  // Ne pas réinitialiser si c'est le même champ (même UUID) - évite d'écraser la saisie en cours
  if (newField && localField.value && newField.uuid === localField.value.uuid) {
    return
  }
  
  if (newField) {
    const copy = JSON.parse(JSON.stringify(newField))
    // Ensure defaults for nested objects
    copy.wrapper = { width: '100', ...copy.wrapper }
    copy.foOptions = { visible: true, ...copy.foOptions }
    copy.validation = copy.validation && typeof copy.validation === 'object' && !Array.isArray(copy.validation) ? copy.validation : {}
    copy.config = copy.config || {}
    localField.value = copy

    // Reset slug tracking - for new fields, slug should be auto-generated
    // For existing fields, if slug exists and differs from auto-generated, consider it manually edited
    slugManuallyEdited.value = false
    lastAutoGeneratedSlug.value = ''

    // Auto-generate slug for existing fields with title
    if (newField.title && !newField.slug) {
      nextTick(async () => {
        try {
          const generatedSlug = await api.slugify(newField.title)
          if (localField.value && !slugManuallyEdited.value) {
            localField.value.slug = generatedSlug
            lastAutoGeneratedSlug.value = generatedSlug
            onFieldChange()
          }
        } catch (error) {
          console.error('Error auto-generating slug for existing field:', error)
        }
      })
    }

    // ✅ Focus sur le titre si champ nouveau (pas d'ID)
    if (!newField.id) {
      nextTick(() => {
        const titleInput = document.querySelector('.field-title-input') as HTMLInputElement
        if (titleInput) {
          titleInput.focus()
          titleInput.select() // Sélectionner le texte par défaut pour faciliter la réécriture
        }
      })
    }
  } else {
    localField.value = null
    slugManuallyEdited.value = false
    lastAutoGeneratedSlug.value = ''
  }
}, { immediate: true })

// Auto-generate slug from title (only if slug hasn't been manually edited)
const slugTimeout = ref<number | null>(null)
const isGeneratingSlug = ref<boolean>(false)

function onTitleChange(): void {
  if (!localField.value) return

  // Ne pas auto-générer si le slug a été modifié manuellement
  if (slugManuallyEdited.value) {
    return
  }

  // Always auto-generate on title change (not just for empty slugs)
  // Clear existing timeout
  if (slugTimeout.value) {
    clearTimeout(slugTimeout.value)
  }

  // Set flag to prevent interference
  isGeneratingSlug.value = true

  slugTimeout.value = window.setTimeout(async () => {
    if (!localField.value) {
      isGeneratingSlug.value = false
      return
    }

    // Double check: if slug was manually edited during timeout, don't update
    if (slugManuallyEdited.value) {
      isGeneratingSlug.value = false
      return
    }

    // Only update if title still exists
    if (localField.value.title) {
      try {
        const newSlug = await api.slugify(localField.value.title)
        // Only update if slug hasn't been manually changed
        if (!slugManuallyEdited.value && localField.value) {
          localField.value.slug = newSlug
          lastAutoGeneratedSlug.value = newSlug
          // Update store after slug generation
          onFieldChange()
        }
      } catch (error) {
        console.error('Error generating slug:', error)
      }
    }

    isGeneratingSlug.value = false
  }, 150) // More responsive UX
}

// Track manual slug edits
function onSlugChange(): void {
  if (!localField.value) return
  
  // If slug is different from last auto-generated, mark as manually edited
  if (localField.value.slug !== lastAutoGeneratedSlug.value) {
    slugManuallyEdited.value = true
  }
  
  onFieldChange()
}

// Debounced update for title changes
const titleUpdateTimeout = ref<number | null>(null)

// Update local store (no API call yet)
function onFieldChange(): void {
  if (!localField.value) return
  store.updateFieldLocal(localField.value)
}

// Debounced update for title (to avoid too many store updates while typing)
function debouncedFieldUpdate(): void {
  if (titleUpdateTimeout.value) {
    clearTimeout(titleUpdateTimeout.value)
  }
  titleUpdateTimeout.value = window.setTimeout(() => {
    onFieldChange()
  }, 300)
}

// Handlers for boolean switches
function onFoVisibleChange(val: boolean): void {
  if (!localField.value) return
  localField.value.foOptions.visible = val
  onFieldChange()
}

// Save to API
async function saveFieldToApi(): Promise<void> {
  if (!localField.value) return
  await store.saveField(localField.value)
}

// Check if field needs saving (new or modified)
const needsSaving = computed(() => {
  if (!localField.value) return false
  // New field without ID needs saving
  if (!localField.value.id && localField.value.title.trim()) return true
  return false
})

// Get field type config component
const fieldConfigComponent = computed(() => {
  if (!localField.value) return null

  switch (localField.value.type) {
    case 'text':
      return TextFieldConfig
    case 'textarea':
      return TextareaFieldConfig
    case 'number':
      return NumberFieldConfig
    case 'email':
      return EmailFieldConfig
    case 'url':
      return UrlFieldConfig
    case 'select':
      return SelectFieldConfig
    case 'checkbox':
      return CheckboxFieldConfig
    case 'radio':
      return RadioFieldConfig
    case 'boolean':
      return BooleanFieldConfig
    case 'date':
      return DateFieldConfig
    case 'time':
      return TimeFieldConfig
    case 'datetime':
      return DatetimeFieldConfig
    case 'color':
      return ColorFieldConfig
    case 'richtext':
      return RichTextFieldConfig
    case 'file':
      return FileFieldConfig
    case 'image':
      return ImageFieldConfig
    case 'video':
      return VideoFieldConfig
    case 'gallery':
      return GalleryFieldConfig
    case 'files':
      return FilesFieldConfig
    case 'relation':
      return RelationFieldConfig
    case 'list':
      return ListFieldConfig
    case 'repeater':
      return RepeaterFieldConfig
    default:
      return null
  }
})

// Computed property for required field to ensure reactivity
const fieldRequired = computed({
  get: () => {
    if (!localField.value?.validation) return false
    return !!localField.value.validation.required
  },
  set: (value: boolean) => {
    if (!localField.value) return
    if (!localField.value.validation) {
      localField.value.validation = {}
    }
    localField.value.validation.required = value
    onFieldChange()
  }
})

// Computed property for slug field readonly state
const slugReadonly = computed(() => {
  return !slugManuallyEdited.value
})

// Method to handle slug field focus
function onSlugFocus(): void {
  if (!slugManuallyEdited.value) {
    slugManuallyEdited.value = true
  }
}

// Watch validation changes to trigger store updates
watch(() => localField.value?.validation?.minLength, (newVal) => {
  if (newVal !== undefined) onFieldChange()
})

watch(() => localField.value?.validation?.maxLength, (newVal) => {
  if (newVal !== undefined) onFieldChange()
})

watch(() => localField.value?.validation?.pattern, (newVal) => {
  if (newVal !== undefined) onFieldChange()
})

watch(() => localField.value?.validation?.min, (newVal) => {
  if (newVal !== undefined) onFieldChange()
})

watch(() => localField.value?.validation?.max, (newVal) => {
  if (newVal !== undefined) onFieldChange()
})

watch(() => localField.value?.validation?.message, (newVal) => {
  if (newVal !== undefined) onFieldChange()
})

const layoutOptions = computed(() => window.acfConfig?.layoutOptions || { widths: [], positions: [] })

// Cleanup timeouts on unmount
onBeforeUnmount(() => {
  if (slugTimeout.value) {
    clearTimeout(slugTimeout.value)
  }
  if (titleUpdateTimeout.value) {
    clearTimeout(titleUpdateTimeout.value)
  }
})
</script>

<template>
  <div class="acfps-field-configurator">
    <!-- No field selected -->
    <div v-if="!localField" class="acfps-empty-state">
      <span class="material-icons">touch_app</span>
      <p>{{ t('selectField') }}</p>
    </div>

    <!-- Field editor -->
    <template v-else>
      <!-- Save button for new unsaved fields -->
      <div v-if="needsSaving" class="acfps-save-field-bar">
        <button
          class="btn btn-primary btn-sm"
          :disabled="store.saving"
          @click="saveFieldToApi"
        >
          <span v-if="store.saving">{{ t('saving') }}</span>
          <span v-else>{{ t('save') }} Field</span>
        </button>
        <small class="text-muted ml-2">This field hasn't been saved yet</small>
      </div>

      <!-- Config tabs -->
      <div class="acfps-config-tabs">
        <button
          class="acfps-config-tab"
          :class="{ active: activeTab === 'general' }"
          @click="activeTab = 'general'"
        >
          {{ t('general') }}
        </button>
        <button
          class="acfps-config-tab"
          :class="{ active: activeTab === 'validation' }"
          @click="activeTab = 'validation'"
        >
          {{ t('validation') }}
        </button>
        <button
          class="acfps-config-tab"
          :class="{ active: activeTab === 'presentation' }"
          @click="activeTab = 'presentation'"
        >
          {{ t('presentation') }}
        </button>
      </div>

      <div class="config-content">
        <!-- General tab -->
        <template v-if="activeTab === 'general'">
          <!-- Field Status -->
          <div class="acfps-form-section">
            <div class="form-group">
              <label class="form-control-label">{{ t('active') }}</label>
              <PsSwitch
                v-model="localField.active"
                id="field-active"
                @update:model-value="onFieldChange"
              />
              <small class="form-text text-muted">
                Enable or disable this field.
              </small>
            </div>
          </div>

          <div class="acfps-form-section">
            <div class="form-group">
              <label class="form-control-label">{{ t('fieldTitle') }} *</label>
              <input
                v-model="localField.title"
                type="text"
                class="form-control field-title-input"
                @input="() => { onTitleChange(); debouncedFieldUpdate() }"
                @blur="onFieldChange"
              >
            </div>

            <div class="form-group">
              <label class="form-control-label">{{ t('fieldSlug') }} *</label>
              <input
                v-model="localField.slug"
                type="text"
                class="form-control"
                pattern="[a-z0-9_]+"
                :readonly="slugReadonly"
                :class="{ 'bg-light': slugReadonly }"
                @input="onSlugChange"
                @focus="onSlugFocus"
              >
              <small class="form-text text-muted">
                <span v-if="slugReadonly">Auto-generated from title. Click to edit manually.</span>
                <span v-else>Use lowercase letters, numbers, and underscores only.</span>
              </small>
            </div>

            <div class="form-group">
              <label class="form-control-label">{{ t('fieldInstructions') }}</label>
              <textarea
                v-model="localField.instructions"
                class="form-control"
                rows="3"
                @input="onFieldChange"
              />
              <small class="form-text text-muted">
                Help text shown below the field in the back-office.
              </small>
            </div>
          </div>

          <!-- Type-specific config -->
          <div v-if="fieldConfigComponent" class="acfps-form-section">
            <h4>{{ t('fieldType') }}: {{ localField.type }}</h4>
            <component
              :is="fieldConfigComponent"
              v-model:config="localField.config"
              @update:config="onFieldChange"
            />
          </div>
        </template>

        <!-- Validation tab -->
        <template v-if="activeTab === 'validation'">
          <div class="acfps-form-section">
            <div class="form-group">
              <label class="form-control-label">{{ t('required') }}</label>
              <PsSwitch
                v-model="fieldRequired"
                id="field-required"
              />
            </div>

            <template v-if="localField.type === 'text'">
                <div class="form-row">
                <div class="form-group col-6">
                  <label class="form-control-label">{{ t('minLength') }}</label>
                  <input
                    v-model.number="localField.validation.minLength"
                    type="number"
                    class="form-control"
                    min="0"
                  >
                </div>
                <div class="form-group col-6">
                  <label class="form-control-label">{{ t('maxLength') }}</label>
                  <input
                    v-model.number="localField.validation.maxLength"
                    type="number"
                    class="form-control"
                    min="0"
                  >
                </div>
              </div>

              <div class="form-group">
                <label class="form-control-label">{{ t('pattern') }}</label>
                <input
                  v-model="localField.validation.pattern"
                  type="text"
                  class="form-control"
                  placeholder="^[A-Z].*$"
                >
              </div>
            </template>

            <template v-if="localField.type === 'number'">
              <div class="form-row">
                <div class="form-group col-6">
                  <label class="form-control-label">{{ t('minValue') }}</label>
                  <input
                    v-model.number="localField.validation.min"
                    type="number"
                    class="form-control"
                  >
                </div>
                <div class="form-group col-6">
                  <label class="form-control-label">{{ t('maxValue') }}</label>
                  <input
                    v-model.number="localField.validation.max"
                    type="number"
                    class="form-control"
                  >
                </div>
              </div>
            </template>

            <div class="form-group">
              <label class="form-control-label">{{ t('errorMessage') }}</label>
              <input
                v-model="localField.validation.message"
                type="text"
                class="form-control"
                :placeholder="t('errorMessage')"
              >
            </div>
          </div>
        </template>

        <!-- Presentation tab -->
        <template v-if="activeTab === 'presentation'">
          <div class="acfps-form-section">
            <div class="form-group">
              <label class="form-control-label">{{ t('wrapperWidth') }}</label>
              <select
                v-model="localField.wrapper.width"
                class="form-control"
                @change="onFieldChange"
              >
                <option
                  v-for="opt in layoutOptions.widths"
                  :key="opt.value"
                  :value="opt.value"
                >
                  {{ opt.label }}
                </option>
              </select>
            </div>

            <div class="form-group">
              <label class="form-control-label">{{ t('wrapperClass') }}</label>
              <input
                v-model="localField.wrapper.class"
                type="text"
                class="form-control"
                placeholder="my-custom-class"
                @input="onFieldChange"
              >
            </div>

            <div class="form-group">
              <label class="form-control-label">{{ t('wrapperId') }}</label>
              <input
                v-model="localField.wrapper.id"
                type="text"
                class="form-control"
                placeholder="my-field-id"
                @input="onFieldChange"
              >
            </div>
          </div>

          <div class="acfps-form-section">
            <h4>{{ t('frontendOptions') }}</h4>

            <div class="form-group">
              <label class="form-control-label">{{ t('translatable') }}</label>
              <PsSwitch
                v-model="localField.translatable"
                id="field-translatable"
                @update:model-value="onFieldChange"
              />
            </div>

            <div class="form-group">
              <label class="form-control-label">{{ t('showOnFrontend') }}</label>
              <PsSwitch
                :model-value="!!localField.foOptions.visible"
                id="field-fo-visible"
                @update:model-value="onFoVisibleChange"
              />
            </div>
          </div>
        </template>
      </div>
    </template>
  </div>
</template>

<style scoped>
.acfps-field-configurator {
  display: flex;
  flex-direction: column;
  height: 100%;
}

.config-content {
  flex: 1;
  overflow-y: auto;
}

.form-row {
  display: flex;
  margin: 0 -0.5rem;
}

.form-row .form-group {
  padding: 0 0.5rem;
}

.col-6 {
  flex: 0 0 50%;
  max-width: 50%;
}

.acfps-save-field-bar {
  display: flex;
  align-items: center;
  padding: 0.75rem 1rem;
  background: #fff3cd;
  border-bottom: 1px solid #ffc107;
  margin-bottom: 0.5rem;
}

.acfps-save-field-bar .ml-2 {
  margin-left: 0.5rem;
}
</style>

