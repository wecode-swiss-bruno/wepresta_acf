<script setup lang="ts">
import { ref, computed, watch, nextTick, onBeforeUnmount } from 'vue'
import { useBuilderStore } from '@/stores/builderStore'
import { useTranslations } from '@/composables/useTranslations'
import { useApi } from '@/composables/useApi'
import type { AcfField } from '@/types'
import TextFieldConfig from '@/components/fields/TextFieldConfig.vue'
import TextareaFieldConfig from '@/components/fields/TextareaFieldConfig.vue'
import NumberFieldConfig from '@/components/fields/NumberFieldConfig.vue'
import EmailFieldConfig from '@/components/fields/EmailFieldConfig.vue'
import UrlFieldConfig from '@/components/fields/UrlFieldConfig.vue'
import SelectFieldConfig from '@/components/fields/SelectFieldConfig.vue'
import CheckboxFieldConfig from '@/components/fields/CheckboxFieldConfig.vue'
import RadioFieldConfig from '@/components/fields/RadioFieldConfig.vue'
import BooleanFieldConfig from '@/components/fields/BooleanFieldConfig.vue'
import DateFieldConfig from '@/components/fields/DateFieldConfig.vue'
import TimeFieldConfig from '@/components/fields/TimeFieldConfig.vue'
import DatetimeFieldConfig from '@/components/fields/DatetimeFieldConfig.vue'
import ColorFieldConfig from '@/components/fields/ColorFieldConfig.vue'
import RichTextFieldConfig from '@/components/fields/RichTextFieldConfig.vue'
import FileFieldConfig from '@/components/fields/FileFieldConfig.vue'
import ImageFieldConfig from '@/components/fields/ImageFieldConfig.vue'
import VideoFieldConfig from '@/components/fields/VideoFieldConfig.vue'
import GalleryFieldConfig from '@/components/fields/GalleryFieldConfig.vue'
import FilesFieldConfig from '@/components/fields/FilesFieldConfig.vue'
import RelationFieldConfig from '@/components/fields/RelationFieldConfig.vue'
import ListFieldConfig from '@/components/fields/ListFieldConfig.vue'
import RepeaterFieldConfig from '@/components/fields/RepeaterFieldConfig.vue'
import PsSwitch from '@/components/ui/PsSwitch.vue'

const store = useBuilderStore()
const { t } = useTranslations()
const api = useApi()

const activeTab = ref<'general' | 'validation' | 'presentation'>('general')

// Local copy for editing
const localField = ref<AcfField | null>(null)

// Track if slug was manually edited by user
const slugManuallyEdited = ref<boolean>(false)
// Track the last auto-generated slug to detect manual changes
const lastAutoGeneratedSlug = ref<string>('')

// Language management
const currentLangCode = ref<string>('en')
const languages = computed(() => window.acfConfig?.languages || [])
const defaultLanguage = computed(() => languages.value.find((l: any) => l.is_default) || languages.value[0])

// Sync with store selection
watch(() => store.selectedField, (newField) => {
  // Ne pas réinitialiser si c'est le même champ (même UUID) - évite d'écraser la saisie en cours
  if (newField && localField.value && newField.uuid === localField.value.uuid) {
    return
  }
  
  if (newField) {
    const copy = JSON.parse(JSON.stringify(newField))
    // Ensure defaults for nested objects
    copy.wrapper = { width: '100', ...copy.wrapper }
    copy.validation = copy.validation && typeof copy.validation === 'object' && !Array.isArray(copy.validation) ? copy.validation : {}
    copy.config = copy.config || {}
    copy.foOptions = copy.foOptions && typeof copy.foOptions === 'object' && !Array.isArray(copy.foOptions) ? copy.foOptions : {}

    // Ensure showTitle is always defined with a default value
    if (copy.foOptions.showTitle === undefined) {
      copy.foOptions.showTitle = true // Default: show title by default
    }

    // Initialize translations if not present or if it's an array (PHP returns [] for empty)
    // IMPORTANT: Array.isArray([]) is true, so we must convert to object
    if (!copy.translations || Array.isArray(copy.translations) || typeof copy.translations !== 'object') {
      copy.translations = {}
    }
    
    // Ensure all languages have translation entries
    languages.value.forEach((lang: any) => {
      if (!copy.translations![lang.code]) {
        copy.translations![lang.code] = {
          title: copy.title || '',
          instructions: copy.instructions || ''
        }
      }
    })
    
    localField.value = copy
    
    // Set current language to default
    if (defaultLanguage.value) {
      currentLangCode.value = defaultLanguage.value.code
    }

    // Reset slug tracking - for new fields, slug should be auto-generated
    // For existing fields, if slug exists and differs from auto-generated, consider it manually edited
    slugManuallyEdited.value = false
    lastAutoGeneratedSlug.value = ''

    // Auto-generate slug for existing fields with title
    if (newField.title && !newField.slug) {
      nextTick(async () => {
        try {
          const baseSlug = await api.slugify(newField.title)
          const uniqueSlug = generateUniqueSlug(baseSlug, newField.uuid)
          if (localField.value && !slugManuallyEdited.value) {
            localField.value.slug = uniqueSlug
            lastAutoGeneratedSlug.value = uniqueSlug
            onFieldChange()
          }
        } catch (error) {
          console.error('Error auto-generating slug for existing field:', error)
        }
      })
    }

    // ✅ Focus sur le titre si champ nouveau (pas d'ID)
    if (!newField.id) {
      nextTick(() => {
        const titleInput = document.querySelector('.field-title-input') as HTMLInputElement
        if (titleInput) {
          titleInput.focus()
          titleInput.select() // Sélectionner le texte par défaut pour faciliter la réécriture
        }
      })
    }
  } else {
    localField.value = null
    slugManuallyEdited.value = false
    lastAutoGeneratedSlug.value = ''
  }
}, { immediate: true })

// Auto-generate slug from title (only if slug hasn't been manually edited)
const slugTimeout = ref<number | null>(null)
const isGeneratingSlug = ref<boolean>(false)

// Génère un slug unique en évitant les conflits avec les slugs existants
function generateUniqueSlug(baseSlug: string, excludeUuid?: string): string {
  const existingSlugs = store.currentGroup.value?.fields
    ?.filter(f => f.uuid !== excludeUuid && f.slug)
    ?.map(f => f.slug) || []

  // Si le slug de base n'existe pas, le retourner tel quel
  if (!existingSlugs.includes(baseSlug)) {
    return baseSlug
  }

  // Sinon, trouver le prochain numéro disponible
  const similarSlugs = existingSlugs
    .filter(s => s.startsWith(`${baseSlug}_`))
    .map(s => parseInt(s.split('_').pop() || '0', 10))
    .filter(n => !isNaN(n))

  const nextNumber = similarSlugs.length > 0 ? Math.max(...similarSlugs) + 1 : 2
  return `${baseSlug}_${nextNumber}`
}

function onTitleChange(): void {
  if (!localField.value) return

  // Ne pas auto-générer si le slug a été modifié manuellement
  if (slugManuallyEdited.value) {
    return
  }

  // Always auto-generate on title change (not just for empty slugs)
  // Clear existing timeout
  if (slugTimeout.value) {
    clearTimeout(slugTimeout.value)
  }

  // Set flag to prevent interference
  isGeneratingSlug.value = true

  slugTimeout.value = window.setTimeout(async () => {
    if (!localField.value) {
      isGeneratingSlug.value = false
      return
    }

    // Double check: if slug was manually edited during timeout, don't update
    if (slugManuallyEdited.value) {
      isGeneratingSlug.value = false
      return
    }

    // Only update if title still exists
    if (localField.value.title) {
      try {
        const baseSlug = await api.slugify(localField.value.title)
        const uniqueSlug = generateUniqueSlug(baseSlug, localField.value.uuid)
        // Only update if slug hasn't been manually changed
        if (!slugManuallyEdited.value && localField.value) {
          localField.value.slug = uniqueSlug
          lastAutoGeneratedSlug.value = uniqueSlug
          // Update store after slug generation
          onFieldChange()
        }
      } catch (error) {
        console.error('Error generating slug:', error)
      }
    }

    isGeneratingSlug.value = false
  }, 150) // More responsive UX
}

// Handle translation changes
function onTranslationChange(langCode: string): void {
  if (!localField.value || !localField.value.translations) return
  
  // If editing default language, sync with main title/instructions
  const defaultLang = defaultLanguage.value
  if (defaultLang && langCode === defaultLang.code && localField.value.translations[langCode]) {
    localField.value.title = localField.value.translations[langCode].title
    localField.value.instructions = localField.value.translations[langCode].instructions || ''
    
  }
  
  onFieldChange()
}

// Track manual slug edits
function onSlugChange(): void {
  if (!localField.value) return
  
  // If slug is different from last auto-generated, mark as manually edited
  if (localField.value.slug !== lastAutoGeneratedSlug.value) {
    slugManuallyEdited.value = true
  }
  
  onFieldChange()
}

// Debounced update for title changes
const titleUpdateTimeout = ref<number | null>(null)

// Update local store (no API call yet)
function onFieldChange(): void {
  if (!localField.value) return
  store.updateFieldLocal(localField.value)
}


// Handlers for boolean switches

// Save to API
async function saveFieldToApi(): Promise<void> {
  if (!localField.value) return
  await store.saveField(localField.value)
}

// Check if field needs saving (new or modified)
const needsSaving = computed(() => {
  if (!localField.value) return false
  // New field without ID needs saving
  if (!localField.value.id && localField.value.title.trim()) return true
  return false
})

// Get field type config component
const fieldConfigComponent = computed(() => {
  if (!localField.value) return null

  switch (localField.value.type) {
    case 'text':
      return TextFieldConfig
    case 'textarea':
      return TextareaFieldConfig
    case 'number':
      return NumberFieldConfig
    case 'email':
      return EmailFieldConfig
    case 'url':
      return UrlFieldConfig
    case 'select':
      return SelectFieldConfig
    case 'checkbox':
      return CheckboxFieldConfig
    case 'radio':
      return RadioFieldConfig
    case 'boolean':
      return BooleanFieldConfig
    case 'date':
      return DateFieldConfig
    case 'time':
      return TimeFieldConfig
    case 'datetime':
      return DatetimeFieldConfig
    case 'color':
      return ColorFieldConfig
    case 'richtext':
      return RichTextFieldConfig
    case 'file':
      return FileFieldConfig
    case 'image':
      return ImageFieldConfig
    case 'video':
      return VideoFieldConfig
    case 'gallery':
      return GalleryFieldConfig
    case 'files':
      return FilesFieldConfig
    case 'relation':
      return RelationFieldConfig
    case 'list':
      return ListFieldConfig
    case 'repeater':
      return RepeaterFieldConfig
    default:
      return null
  }
})

// Computed property for required field to ensure reactivity
const fieldRequired = computed({
  get: () => {
    if (!localField.value?.validation) return false
    return !!localField.value.validation.required
  },
  set: (value: boolean) => {
    if (!localField.value) return
    if (!localField.value.validation) {
      localField.value.validation = {}
    }
    localField.value.validation.required = value
    onFieldChange()
  }
})

// Computed property for slug field readonly state
const slugReadonly = computed(() => {
  if (!localField.value) return true

  // Pour les champs non sauvegardés, permettre l'auto-génération
  if (!localField.value.id) {
    return !slugManuallyEdited.value
  }

  // ✅ Pour les champs sauvegardés : TOUJOURS en lecture seule
  return true
})

// Computed property pour savoir si le champ est sauvegardé
const isFieldSaved = computed(() => {
  return localField.value?.id ? true : false
})

// Computed property for value translatable field
const valueTranslatable = computed({
  get: () => {
    if (!localField.value) return false
    return !!localField.value.value_translatable || !!localField.value.translatable
  },
  set: (value: boolean) => {
    if (!localField.value) return
    localField.value.value_translatable = value
    localField.value.translatable = value // Legacy support
    onFieldChange()
  }
})

// Get current field type information
const currentFieldType = computed(() => {
  if (!localField.value?.type) return null
  return store.fieldTypes.find(ft => ft.type === localField.value!.type)
})

// Method to handle slug field focus
function onSlugFocus(): void {
  if (!slugManuallyEdited.value) {
    slugManuallyEdited.value = true
  }
}

// Watch validation changes to trigger store updates
watch(() => localField.value?.validation?.minLength, (newVal) => {
  if (newVal !== undefined) onFieldChange()
})

watch(() => localField.value?.validation?.maxLength, (newVal) => {
  if (newVal !== undefined) onFieldChange()
})

watch(() => localField.value?.validation?.pattern, (newVal) => {
  if (newVal !== undefined) onFieldChange()
})

watch(() => localField.value?.validation?.min, (newVal) => {
  if (newVal !== undefined) onFieldChange()
})

watch(() => localField.value?.validation?.max, (newVal) => {
  if (newVal !== undefined) onFieldChange()
})

watch(() => localField.value?.validation?.message, (newVal) => {
  if (newVal !== undefined) onFieldChange()
})

// Auto-reset valueTranslatable when field type changes to non-supporting type
watch(() => localField.value?.type, (newType) => {
  if (!newType || !localField.value) return

  const fieldType = store.fieldTypes.find(ft => ft.type === newType)
  if (fieldType && !fieldType.supportsTranslation) {
    // Automatically disable translation for types that don't support it
    localField.value.value_translatable = false
    localField.value.translatable = false // Legacy support
    onFieldChange()
  }
})

const layoutOptions = computed(() => window.acfConfig?.layoutOptions || { widths: [], positions: [] })

// Cleanup timeouts on unmount
onBeforeUnmount(() => {
  if (slugTimeout.value) {
    clearTimeout(slugTimeout.value)
  }
  if (titleUpdateTimeout.value) {
    clearTimeout(titleUpdateTimeout.value)
  }
})
</script>

<template>
  <div class="acfps-field-configurator">
    <!-- No field selected -->
    <div v-if="!localField" class="acfps-empty-state">
      <span class="material-icons">touch_app</span>
      <p>{{ t('selectField') }}</p>
    </div>

    <!-- Field editor -->
    <template v-else>
      <!-- Save button for new unsaved fields -->
      <div v-if="needsSaving" class="acfps-save-field-bar">
        <button
          class="btn btn-primary btn-sm"
          :disabled="store.saving"
          @click="saveFieldToApi"
        >
          <span v-if="store.saving">{{ t('saving') }}</span>
          <span v-else>{{ t('save') }} Field</span>
        </button>
        <small class="text-muted ml-2">{{ t('fieldNotSaved', 'This field hasn\'t been saved yet') }}</small>
      </div>

      <!-- Config tabs -->
      <div class="acfps-config-tabs">
        <button
          class="acfps-config-tab"
          :class="{ active: activeTab === 'general' }"
          @click="activeTab = 'general'"
        >
          {{ t('general') }}
        </button>
        <button
          class="acfps-config-tab"
          :class="{ active: activeTab === 'validation' }"
          @click="activeTab = 'validation'"
        >
          {{ t('validation') }}
        </button>
        <button
          class="acfps-config-tab"
          :class="{ active: activeTab === 'presentation' }"
          @click="activeTab = 'presentation'"
        >
          {{ t('presentation', 'Presentation') }}
        </button>
      </div>

      <div class="config-content">
        <!-- General tab -->
        <template v-if="activeTab === 'general'">
          <!-- Field Status -->
          <div class="acfps-form-section">
            <div class="form-group">
              <label class="form-control-label">{{ t('active') }}</label>
              <PsSwitch
                v-model="localField.active"
                id="field-active"
                @update:model-value="onFieldChange"
              />
              <small class="form-text text-muted">
                {{ t('enableDisableField', 'Enable or disable this field.') }}
              </small>
            </div>
          </div>

          <!-- Metadata (Multilingual) -->
          <div class="acfps-form-section">
            <h4>{{ t('metadata', 'Field Metadata') }}</h4>
            
            <!-- Language Tabs -->
            <div class="acf-lang-tabs mb-3">
              <button
                v-for="lang in languages"
                :key="lang.code"
                type="button"
                class="acf-lang-tab"
                :class="{ active: currentLangCode === lang.code }"
                @click="currentLangCode = lang.code"
              >
                <span class="flag-icon flag-icon-{{ lang.code }}"></span>
                {{ lang.code.toUpperCase() }}
                <span v-if="lang.is_default" class="badge badge-primary badge-sm ml-1">Default</span>
              </button>
            </div>

            <!-- Fields for each language -->
            <div v-for="lang in languages" :key="lang.code" v-show="currentLangCode === lang.code">
              <div class="form-group">
                <label class="form-control-label">
                  {{ t('fieldTitle') }} ({{ lang.code.toUpperCase() }}) *
                </label>
                <input
                  v-if="localField.translations && localField.translations[lang.code]"
                  v-model="localField.translations[lang.code].title"
                  type="text"
                  class="form-control field-title-input"
                  :class="{ 'font-weight-bold': lang.is_default }"
                  @input="() => { onTranslationChange(lang.code); if (lang.is_default) onTitleChange() }"
                  @blur="onFieldChange"
                >
                <small v-if="lang.is_default" class="form-text text-muted">
                  {{ t('defaultLanguageHelp', 'This is the default language. Title is also used as fallback.') }}
                </small>
              </div>

              <div class="form-group">
                <label class="form-control-label">
                  {{ t('fieldInstructions') }} ({{ lang.code.toUpperCase() }})
                </label>
                <textarea
                  v-if="localField.translations && localField.translations[lang.code]"
                  v-model="localField.translations[lang.code].instructions"
                  class="form-control"
                  rows="3"
                  @input="() => { onTranslationChange(lang.code) }"
                  @blur="onFieldChange"
                />
              </div>

            </div>

            <div class="form-group mt-3">
              <label class="form-control-label">
                {{ t('fieldSlug') }} *
                <!-- Icône de cadenas pour les champs sauvegardés -->
                <i v-if="isFieldSaved"
                   class="material-icons text-warning ml-1"
                   style="font-size: 16px; vertical-align: middle;"
                   :title="t('slugLockedTitle', 'Slug is locked because field is saved')">
                  lock
                </i>
              </label>

              <!-- Input avec style spécial pour champs sauvegardés -->
              <div class="input-group">
                <input
                  v-model="localField.slug"
                  type="text"
                  class="form-control"
                  pattern="[a-z0-9_]+"
                  :disabled="isFieldSaved"
                  :readonly="slugReadonly"
                  :class="{
                    'bg-light': slugReadonly || isFieldSaved,
                    'text-muted': isFieldSaved,
                    'border-secondary': isFieldSaved
                  }"
                  @input="onSlugChange"
                  @focus="onSlugFocus"
                >

                <!-- Badge visuel pour champs sauvegardés -->
                <div v-if="isFieldSaved" class="input-group-append">
                  <span class="input-group-text bg-secondary text-white">
                    <i class="material-icons" style="font-size: 14px;">lock</i>
                    {{ t('locked', 'Locked') }}
                  </span>
                </div>
              </div>

              <!-- Message explicatif selon l'état du champ -->
              <small class="form-text" :class="{ 'text-muted': !isFieldSaved, 'text-warning': isFieldSaved }">
                <span v-if="isFieldSaved">
                  <i class="material-icons" style="font-size: 12px; vertical-align: middle;">info</i>
                  {{ t('slugLockedExplanation', 'This slug cannot be changed because the field has been saved. Changing it could break existing code that references this field.') }}
                </span>
                <span v-else-if="slugReadonly">
                  {{ t('slugAutoGenerated', 'Auto-generated from title. Click to edit manually.') }}
                </span>
                <span v-else>
                  {{ t('slugFormatHelp', 'Use lowercase letters, numbers, and underscores only.') }}
                </span>
              </small>

              <!-- Alerte warning pour renforcer le message -->
              <div v-if="isFieldSaved" class="alert alert-warning mt-2 py-2 px-3" style="font-size: 0.875rem;">
                <div class="d-flex align-items-center">
                  <i class="material-icons text-warning mr-2" style="font-size: 18px;">warning</i>
                  <div>
                    <strong>{{ t('important', 'Important:') }}</strong>
                    {{ t('slugPersistenceNote', 'Once saved, the field slug becomes permanent to maintain data integrity.') }}
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Type-specific config -->
          <div v-if="fieldConfigComponent" class="acfps-form-section">
            <h4>{{ t('fieldType') }}: {{ localField.type }}</h4>
            <component
              :is="fieldConfigComponent"
              v-model:config="localField.config"
              @update:config="onFieldChange"
            />
          </div>
        </template>

        <!-- Validation tab -->
        <template v-if="activeTab === 'validation'">
          <div class="acfps-form-section">
            <div class="form-group">
              <label class="form-control-label">{{ t('required') }}</label>
              <PsSwitch
                v-model="fieldRequired"
                id="field-required"
              />
            </div>

            <template v-if="localField.type === 'text'">
                <div class="form-row">
                <div class="form-group col-6">
                  <label class="form-control-label">{{ t('minLength') }}</label>
                  <input
                    v-model.number="localField.validation.minLength"
                    type="number"
                    class="form-control"
                    min="0"
                  >
                </div>
                <div class="form-group col-6">
                  <label class="form-control-label">{{ t('maxLength') }}</label>
                  <input
                    v-model.number="localField.validation.maxLength"
                    type="number"
                    class="form-control"
                    min="0"
                  >
                </div>
              </div>

              <div class="form-group">
                <label class="form-control-label">{{ t('pattern') }}</label>
                <input
                  v-model="localField.validation.pattern"
                  type="text"
                  class="form-control"
                  placeholder="^[A-Z].*$"
                >
              </div>
            </template>

            <template v-if="localField.type === 'number'">
              <div class="form-row">
                <div class="form-group col-6">
                  <label class="form-control-label">{{ t('minValue') }}</label>
                  <input
                    v-model.number="localField.validation.min"
                    type="number"
                    class="form-control"
                  >
                </div>
                <div class="form-group col-6">
                  <label class="form-control-label">{{ t('maxValue') }}</label>
                  <input
                    v-model.number="localField.validation.max"
                    type="number"
                    class="form-control"
                  >
                </div>
              </div>
            </template>

            <div class="form-group">
              <label class="form-control-label">{{ t('errorMessage') }}</label>
              <input
                v-model="localField.validation.message"
                type="text"
                class="form-control"
                :placeholder="t('errorMessage')"
              >
            </div>
          </div>
        </template>

        <!-- Presentation tab -->
        <template v-if="activeTab === 'presentation'">
          <div class="acfps-form-section">
            <div class="form-group">
              <label class="form-control-label">{{ t('showTitle', 'Show field title') }}</label>
              <PsSwitch
                v-model="localField.foOptions.showTitle"
                id="field-show-title"
                @update:model-value="onFieldChange"
              />
              <small class="form-text text-muted">
                {{ t('showTitleHelp', 'Display the field title in front-office rendering.') }}
              </small>
            </div>
            <div class="form-group">
              <label class="form-control-label">{{ t('valueTranslatable', 'Value translatable') }}</label>
              <PsSwitch
                v-model="valueTranslatable"
                id="field-value-translatable"
                :disabled="!currentFieldType?.supportsTranslation"
              />
              <small class="form-text text-muted">
                {{ t('valueTranslatableHelp', 'Enable to allow translation of field values for multi-language support.') }}
              </small>
              <small v-if="!currentFieldType?.supportsTranslation" class="form-text text-warning">
                {{ t('translationNotSupported', 'This field type does not support translation.') }}
              </small>
            </div>

            <div class="form-group">
              <label class="form-control-label">{{ t('customClass', 'Custom CSS Class') }}</label>
              <input
                v-model="localField.foOptions.customClass"
                type="text"
                class="form-control"
                :placeholder="'my-custom-field-class'"
                @input="onFieldChange"
              >
              <small class="form-text text-muted">
                {{ t('customClassHelp', 'Add custom CSS classes to the field container for styling.') }}
              </small>
            </div>

            <div class="form-group">
              <label class="form-control-label">{{ t('customId', 'Custom HTML ID') }}</label>
              <input
                v-model="localField.foOptions.customId"
                type="text"
                class="form-control"
                :placeholder="'my-custom-field-id'"
                @input="onFieldChange"
              >
              <small class="form-text text-muted">
                {{ t('customIdHelp', 'Add a custom HTML ID to the field for JavaScript targeting.') }}
              </small>
            </div>
          </div>
        </template>

      </div>
    </template>
  </div>
</template>

<style scoped>
.acfps-field-configurator {
  display: flex;
  flex-direction: column;
  height: 100%;
}

.config-content {
  flex: 1;
  overflow-y: auto;
}

.form-row {
  display: flex;
  margin: 0 -0.5rem;
}

.form-row .form-group {
  padding: 0 0.5rem;
}

.col-6 {
  flex: 0 0 50%;
  max-width: 50%;
}

.acfps-save-field-bar {
  display: flex;
  align-items: center;
  padding: 0.75rem 1rem;
  background: #fff3cd;
  border-bottom: 1px solid #ffc107;
  margin-bottom: 0.5rem;
}

.acfps-save-field-bar .ml-2 {
  margin-left: 0.5rem;
}

/* Language tabs */
.acf-lang-tabs {
  display: flex;
  gap: 0.5rem;
  flex-wrap: wrap;
  border-bottom: 2px solid #e9ecef;
  padding-bottom: 0.5rem;
}

.acf-lang-tab {
  display: flex;
  align-items: center;
  gap: 0.25rem;
  padding: 0.5rem 1rem;
  border: 1px solid #dee2e6;
  border-radius: 4px 4px 0 0;
  background: #f8f9fa;
  color: #495057;
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: 0.85rem;
  font-weight: 500;
}

.acf-lang-tab:hover {
  background: #e9ecef;
  border-color: #adb5bd;
}

.acf-lang-tab.active {
  background: white;
  border-bottom-color: white;
  color: #007bff;
  font-weight: 600;
  border-color: #007bff;
  position: relative;
  margin-bottom: -2px;
  padding-bottom: calc(0.5rem + 2px);
}

.acf-lang-tab .badge {
  font-size: 0.65rem;
  padding: 0.1rem 0.3rem;
}
</style>

