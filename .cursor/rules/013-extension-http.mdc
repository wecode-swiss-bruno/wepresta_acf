---
description: Extension HTTP WEDEV - Client HTTP unifiÃ©
globs: ["**/Extension/Http/**/*.php"]
alwaysApply: false
---

# Extension HTTP WEDEV

## ğŸ¯ Objectif

Client HTTP lÃ©ger et typÃ© pour les modules PrestaShop, sans dÃ©pendance externe (pas de Guzzle).

## ğŸ“¦ Composants

| Fichier | RÃ´le |
|---------|------|
| `HttpClient` | Client principal avec fluent API |
| `HttpResponse` | RÃ©ponse typÃ©e avec helpers |
| `HttpException` | Exceptions HTTP typÃ©es |
| `RetryStrategy` | Backoff exponentiel |
| `RateLimitHandler` | Rate limiting cÃ´tÃ© client |
| `Auth/*` | StratÃ©gies d'authentification |

## âœ… Bonnes Pratiques

### Utilisation du Client

```php
// âœ… BON: Fluent API, rÃ©utilisable
$client = (new HttpClient())
    ->withAuth(new BearerAuth($apiKey))
    ->withRetry(3)
    ->withTimeout(60);

$response = $client->postJson($url, $data);

// âŒ MAUVAIS: RecrÃ©er le client Ã  chaque fois
$response = (new HttpClient())
    ->withAuth(new BearerAuth($apiKey))
    ->postJson($url, $data);
```

### Gestion des RÃ©ponses

```php
// âœ… BON: VÃ©rifier le succÃ¨s avant de parser
$response = $client->get($url);
if ($response->isSuccess()) {
    $data = $response->json();
}

// âœ… BON: Utiliser throw() pour simplifier
try {
    $data = $client->get($url)->throw()->json();
} catch (HttpException $e) {
    // GÃ©rer l'erreur
}

// âŒ MAUVAIS: AccÃ©der au JSON sans vÃ©rification
$data = $client->get($url)->json(); // Peut Ã©chouer si erreur
```

### Authentification

```php
// âœ… BON: Stocker les credentials dans Configuration
$apiKey = $this->config->get('MYMODULE_API_KEY');
$auth = new BearerAuth($apiKey);

// âŒ MAUVAIS: Credentials en dur
$auth = new BearerAuth('sk_live_xxxx');
```

### Retry

```php
// âœ… BON: Retry avec backoff pour APIs externes
$client->withRetry(3)->get('https://api.openai.com/...');

// âŒ MAUVAIS: Retry excessif
$client->withRetry(10)->get($url); // Trop de retries
```

### Rate Limiting

```php
// âœ… BON: Respecter les limites d'API
$client = (new HttpClient())
    ->withRateLimit(10, 1);  // 10 req/s pour OpenAI

// âœ… BON: Lire les headers de rate limit
$remaining = $response->getHeader('x-rate-limit-remaining');
if ((int) $remaining < 10) {
    sleep(1);
}
```

## ğŸ”’ SÃ©curitÃ©

### Ne JAMAIS

```php
// âŒ Logger les credentials
$this->log('debug', 'API Key: ' . $apiKey);

// âŒ Exposer les tokens dans les URLs
$client->get("https://api.com/?token={$token}");

// âŒ Ignorer les erreurs SSL (pas supportÃ© par design)
```

### Toujours

```php
// âœ… Utiliser les headers pour les credentials
$client->withAuth(new BearerAuth($token));

// âœ… Valider les rÃ©ponses
if (!$response->isJson()) {
    throw HttpException::invalidResponse('Expected JSON');
}

// âœ… GÃ©rer les erreurs spÃ©cifiquement
try {
    $response = $client->get($url);
} catch (HttpException $e) {
    if ($e->isRateLimit()) {
        // Attendre et rÃ©essayer
    } elseif ($e->isTimeout()) {
        // API lente, notifier l'admin
    }
}
```

## ğŸ“ Exemples par API

### OpenAI

```php
$client = (new HttpClient())
    ->withAuth(new BearerAuth($_ENV['OPENAI_API_KEY']))
    ->withTimeout(120)
    ->withRetry(3)
    ->withRateLimit(60, 60);

$response = $client->postJson(
    'https://api.openai.com/v1/chat/completions',
    [
        'model' => 'gpt-4',
        'messages' => [
            ['role' => 'user', 'content' => 'Hello!']
        ]
    ]
);
```

### Stripe

```php
$client = (new HttpClient())
    ->withAuth(new BearerAuth($_ENV['STRIPE_SECRET']))
    ->withRetry(3);

$response = $client->post(
    'https://api.stripe.com/v1/charges',
    ['amount' => 1000, 'currency' => 'eur']
);
```

### OAuth2 Service

```php
$auth = new OAuth2Auth(
    clientId: $config->get('CLIENT_ID'),
    clientSecret: $config->get('CLIENT_SECRET'),
    tokenUrl: 'https://auth.service.com/oauth/token',
    scopes: ['read', 'write']
);

$client = (new HttpClient())->withAuth($auth);
// Le token est gÃ©rÃ© automatiquement
```

## ğŸ§ª Tests

```php
// Mocker le HttpClient pour les tests
class FakeHttpClient extends HttpClient
{
    private array $responses = [];

    public function addResponse(string $url, HttpResponse $response): void
    {
        $this->responses[$url] = $response;
    }

    protected function doRequest(...): HttpResponse
    {
        return $this->responses[$url] ?? new HttpResponse(404, '');
    }
}
```
