---
description: S√©curit√© du module - SQL Injection, XSS, CSRF, Validation
globs: ["**/*.php", "**/*.tpl", "**/*.twig"]
alwaysApply: false
---

# S√©curit√© du Module

## üõ°Ô∏è R√®gles Critiques

### 1. Protection contre l'acc√®s direct

```php
<?php
// OBLIGATOIRE en haut de CHAQUE fichier PHP accessible
if (!defined('_PS_VERSION_')) {
    exit;
}
```

### 2. D√©clarations de types stricts

```php
<?php
declare(strict_types=1);

// Types stricts sur TOUTES les m√©thodes
public function processData(int $id, string $name): ?array
{
    // ...
}
```

## üíâ Protection SQL Injection

### ‚ùå INTERDIT - Injection SQL possible

```php
// JAMAIS FAIRE √áA - SQL Injection!
$id = $_GET['id'];
$sql = "SELECT * FROM table WHERE id = $id";

$name = Tools::getValue('name');
$sql = "SELECT * FROM table WHERE name = '$name'";

$search = $request->get('search');
$sql = "SELECT * FROM table WHERE name LIKE '%$search%'";
```

### ‚úÖ CORRECT - Protection SQL

```php
// Toujours caster les entiers
$id = (int) Tools::getValue('id');
$sql = "SELECT * FROM " . _DB_PREFIX_ . "table WHERE id = " . $id;

// Toujours utiliser pSQL() pour les strings
$name = pSQL(Tools::getValue('name'));
$sql = "SELECT * FROM " . _DB_PREFIX_ . "table WHERE name = '" . $name . "'";

// pSQL avec true pour le HTML
$description = pSQL(Tools::getValue('description'), true);

// Utiliser les param√®tres bind√©s avec DbQuery
$query = new DbQuery();
$query->select('*')
    ->from('table')
    ->where('id = ' . (int) $id)
    ->where('name = \'' . pSQL($name) . '\'');

// Avec Doctrine DBAL - Param√®tres nomm√©s
$connection->executeQuery(
    'SELECT * FROM ps_table WHERE id = :id AND name = :name',
    ['id' => $id, 'name' => $name],
    ['id' => ParameterType::INTEGER, 'name' => ParameterType::STRING]
);

// LIKE s√©curis√©
$search = pSQL($search);
$sql = "SELECT * FROM table WHERE name LIKE '%" . $search . "%'";

// IN clause s√©curis√©
$ids = array_map('intval', $ids);
$sql = "SELECT * FROM table WHERE id IN (" . implode(',', $ids) . ")";
```

## üîê Protection XSS (Cross-Site Scripting)

### ‚ùå INTERDIT - XSS possible

```php
// Dans un template Smarty
{$user_input}  // NON √âCHAPP√â!

// Dans le PHP
echo $userInput;
echo $_GET['param'];
```

### ‚úÖ CORRECT - Protection XSS

```smarty
{* Smarty - √âchappement automatique avec escape *}
{$user_input|escape:'html':'UTF-8'}

{* Pour les URLs *}
{$url|escape:'url'}

{* Pour le JavaScript *}
{$data|escape:'javascript'}

{* HTML autoris√© (apr√®s sanitization c√¥t√© serveur!) *}
{$html_content nofilter}
```

```twig
{# Twig - √âchappement automatique par d√©faut #}
{{ user_input }}

{# D√©sactiver l'√©chappement (DANGEREUX - seulement si sanitized!) #}
{{ html_content|raw }}

{# √âchappement explicite #}
{{ user_input|e('html') }}
```

```php
// PHP - Toujours √©chapper les sorties
echo htmlspecialchars($userInput, ENT_QUOTES, 'UTF-8');

// Utiliser Tools::safeOutput()
echo Tools::safeOutput($userInput);

// Sanitizer le HTML avant stockage
$cleanHtml = Tools::purifyHTML($htmlContent);
```

### Content Security Policy (CSP)

```php
// Dans hookDisplayHeader
public function hookDisplayHeader(array $params): string
{
    // Ajouter des headers CSP
    header("Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';");

    return '';
}
```

## üîí Protection CSRF (Cross-Site Request Forgery)

### ‚ùå INTERDIT - Pas de protection CSRF

```php
// Formulaire sans token
if (Tools::isSubmit('submitForm')) {
    $this->processForm();  // DANGEREUX!
}
```

### ‚úÖ CORRECT - Protection CSRF

```php
// G√©n√©ration du token dans le formulaire
public function hookDisplayHome(array $params): string
{
    $this->context->smarty->assign([
        'token' => Tools::getToken(false),
    ]);
    return $this->fetch('...');
}

// V√©rification du token
public function processForm(): void
{
    // M√©thode 1: Token PrestaShop
    if (!Tools::isSubmit('submitModulestarter') || !$this->isTokenValid()) {
        $this->errors[] = $this->trans('Invalid security token.');
        return;
    }

    // M√©thode 2: Token explicite
    $submittedToken = Tools::getValue('token');
    if (!Tools::getToken(false) === $submittedToken) {
        $this->errors[] = $this->trans('Invalid security token.');
        return;
    }
}

// Dans le template Smarty
<form method="post">
    <input type="hidden" name="token" value="{$token}">
    <input type="hidden" name="submitModulestarter" value="1">
    <!-- ... -->
</form>

// Dans un contr√¥leur Symfony
public function deleteAction(int $id, Request $request): Response
{
    if (!$this->isCsrfTokenValid('delete-item-' . $id, $request->request->get('_token'))) {
        throw new AccessDeniedException('Invalid CSRF token');
    }
    // ...
}
```

### Template Twig avec CSRF

```twig
<form method="post" action="{{ path('modulestarter_delete', {'id': item.id}) }}">
    <input type="hidden" name="_token" value="{{ csrf_token('delete-item-' ~ item.id) }}">
    <button type="submit" class="btn btn-danger">Delete</button>
</form>
```

## ‚úÖ Validation des Donn√©es

### Validation d'entr√©e

```php
// Toujours valider et typer les entr√©es
$id = (int) Tools::getValue('id');
if ($id <= 0) {
    throw new \InvalidArgumentException('Invalid ID');
}

$email = Tools::getValue('email');
if (!Validate::isEmail($email)) {
    $this->errors[] = $this->trans('Invalid email address.');
}

$name = Tools::getValue('name');
if (!Validate::isGenericName($name)) {
    $this->errors[] = $this->trans('Invalid name.');
}

// Validators PrestaShop disponibles
Validate::isEmail($value);
Validate::isUrl($value);
Validate::isCleanHtml($value);
Validate::isGenericName($value);
Validate::isPasswd($value);
Validate::isInt($value);
Validate::isUnsignedInt($value);
Validate::isFloat($value);
Validate::isBool($value);
Validate::isDate($value);
Validate::isPrice($value);
Validate::isPhoneNumber($value);
Validate::isPostCode($value);
Validate::isMessage($value);
```

### Validation c√¥t√© formulaire Symfony

```php
use Symfony\Component\Validator\Constraints as Assert;

// Dans un FormType
->add('email', EmailType::class, [
    'constraints' => [
        new Assert\NotBlank(),
        new Assert\Email([
            'mode' => 'strict',
            'message' => 'Please enter a valid email.',
        ]),
    ],
])

->add('website', UrlType::class, [
    'constraints' => [
        new Assert\Url([
            'protocols' => ['http', 'https'],
        ]),
    ],
])

->add('price', NumberType::class, [
    'constraints' => [
        new Assert\Positive(),
        new Assert\LessThanOrEqual(9999.99),
    ],
])
```

## üîë Gestion des Mots de Passe

```php
// JAMAIS stocker en clair!
// ‚ùå $password = Tools::getValue('password');

// ‚úÖ Utiliser password_hash
$hashedPassword = password_hash($password, PASSWORD_DEFAULT);

// ‚úÖ V√©rifier avec password_verify
if (password_verify($inputPassword, $storedHash)) {
    // Authentification r√©ussie
}

// Pour les tokens API, utiliser random_bytes
$apiToken = bin2hex(random_bytes(32));
```

## üîí S√©curit√© des Fichiers

### Upload s√©curis√©

```php
public function handleUpload(array $file): ?string
{
    // V√©rifier l'erreur d'upload
    if ($file['error'] !== UPLOAD_ERR_OK) {
        throw new \RuntimeException('Upload failed');
    }

    // V√©rifier le type MIME r√©el (pas l'extension!)
    $finfo = new \finfo(FILEINFO_MIME_TYPE);
    $mimeType = $finfo->file($file['tmp_name']);

    $allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
    if (!in_array($mimeType, $allowedTypes, true)) {
        throw new \RuntimeException('Invalid file type');
    }

    // V√©rifier la taille
    $maxSize = 2 * 1024 * 1024; // 2 MB
    if ($file['size'] > $maxSize) {
        throw new \RuntimeException('File too large');
    }

    // G√©n√©rer un nom unique (JAMAIS utiliser le nom original directement!)
    $extension = match ($mimeType) {
        'image/jpeg' => 'jpg',
        'image/png' => 'png',
        'image/gif' => 'gif',
        'image/webp' => 'webp',
        default => throw new \RuntimeException('Unknown type'),
    };

    $filename = uniqid('img_', true) . '.' . $extension;
    $destination = _PS_MODULE_DIR_ . 'modulestarter/uploads/' . $filename;

    // D√©placer le fichier
    if (!move_uploaded_file($file['tmp_name'], $destination)) {
        throw new \RuntimeException('Failed to move uploaded file');
    }

    return $filename;
}
```

### Protection du dossier uploads

```apache
# .htaccess dans le dossier uploads/
<FilesMatch "\.(?:php|phtml|php3|php4|php5|php7|phps)$">
    Require all denied
</FilesMatch>

# D√©sactiver l'ex√©cution de scripts
Options -ExecCGI
AddHandler cgi-script .php .pl .py .jsp .asp .sh .cgi
```

## üîê Permissions et Autorisation

### V√©rifier les permissions admin

```php
// Dans un contr√¥leur Symfony
use PrestaShopBundle\Security\Annotation\AdminSecurity;

/**
 * @AdminSecurity(
 *     "is_granted('read', request.get('_legacy_controller'))",
 *     message="Access denied."
 * )
 */
public function indexAction(): Response
{
    // ...
}

/**
 * @AdminSecurity(
 *     "is_granted('delete', request.get('_legacy_controller'))",
 *     message="You do not have permission to delete."
 * )
 */
public function deleteAction(int $id): Response
{
    // ...
}
```

### V√©rifier le contexte client

```php
public function hookDisplayCustomerAccount(array $params): string
{
    // V√©rifier que le client est connect√©
    if (!$this->context->customer->isLogged()) {
        return '';
    }

    // V√©rifier que le client a acc√®s √† cette ressource
    $customerId = $this->context->customer->id;
    $item = $this->repository->find($itemId);

    if ($item->getCustomerId() !== $customerId) {
        throw new \RuntimeException('Access denied');
    }

    // ...
}
```

## üìù Logging de S√©curit√©

```php
// Logger les √©v√©nements de s√©curit√©
$this->logger->warning('Failed login attempt', [
    'ip' => Tools::getRemoteAddr(),
    'user_agent' => $_SERVER['HTTP_USER_AGENT'] ?? 'unknown',
    'email' => $email,
]);

$this->logger->info('User action', [
    'action' => 'delete_item',
    'item_id' => $itemId,
    'admin_id' => $this->context->employee->id,
    'ip' => Tools::getRemoteAddr(),
]);
```

## üìã Checklist de S√©curit√©

### Avant chaque release

- [ ] Tous les fichiers PHP ont `if (!defined('_PS_VERSION_')) exit;`
- [ ] Tous les inputs utilisateur sont valid√©s
- [ ] Tous les IDs sont cast√©s en `(int)`
- [ ] Toutes les strings SQL utilisent `pSQL()`
- [ ] Tous les formulaires ont une protection CSRF
- [ ] Tous les outputs sont √©chapp√©s (XSS)
- [ ] Les uploads v√©rifient le type MIME r√©el
- [ ] Les dossiers uploads bloquent l'ex√©cution PHP
- [ ] Les actions sensibles v√©rifient les permissions
- [ ] Les mots de passe sont hash√©s avec `password_hash()`
- [ ] Les tokens API utilisent `random_bytes()`
- [ ] Pas de `var_dump()`, `print_r()`, `die()` en production
- [ ] Les erreurs ne r√©v√®lent pas d'informations sensibles

## ‚úÖ R√©sum√© des Bonnes Pratiques

1. **Ne jamais faire confiance aux entr√©es** - Tout valider
2. **Escape en sortie** - Toujours √©chapper selon le contexte
3. **Tokens CSRF** - Sur tous les formulaires qui modifient des donn√©es
4. **Cast les IDs** - Toujours `(int)` pour les identifiants
5. **pSQL()** - Toujours pour les strings en SQL
6. **Types stricts** - `declare(strict_types=1);`
7. **Permissions** - V√©rifier avant chaque action sensible
8. **Logging** - Tracer les √©v√©nements de s√©curit√©
