---
description: Extension Rules WEDEV - Moteur de rÃ¨gles mÃ©tier
globs: ["**/Extension/Rules/**/*.php"]
alwaysApply: false
---

# Extension Rules WEDEV

## ðŸŽ¯ Objectif

Moteur de rÃ¨gles mÃ©tier pour appliquer des conditions et actions dynamiques.

## ðŸ“¦ Composants

| Composant | RÃ´le |
|-----------|------|
| `RuleEngine` | Ã‰value les rÃ¨gles et exÃ©cute les actions |
| `RuleBuilder` | API fluente pour crÃ©er des rÃ¨gles |
| `RuleContext` | Contexte d'Ã©valuation (cart, customer, etc.) |
| `Condition/*` | Conditions prÃªtes Ã  l'emploi |
| `Action/*` | Actions prÃªtes Ã  l'emploi |

## âœ… Bonnes Pratiques

### CrÃ©ation de RÃ¨gles

```php
// âœ… BON: Utiliser le builder
$rule = RuleBuilder::create('promo_vip')
    ->when(new CustomerCondition('group', '=', 3))
    ->and(new CartCondition('total', '>=', 100))
    ->then(new SetContextAction('discount', 10))
    ->priority(10)
    ->build();

// âŒ MAUVAIS: CrÃ©er manuellement
$rule = new Rule('promo', new AndCondition([...]), ...);
```

### Ã‰valuation

```php
// âœ… BON: Ã‰valuer plusieurs rÃ¨gles et exÃ©cuter la premiÃ¨re
$engine->executeFirst($rules, $context);

// âœ… BON: VÃ©rifier avant d'agir
$matchedRule = $engine->evaluateFirst($rules, $context);
if ($matchedRule) {
    // Logique personnalisÃ©e...
}

// âŒ MAUVAIS: Ã‰valuer une par une manuellement
foreach ($rules as $rule) {
    if ($rule->getCondition()->evaluate($context)) { ... }
}
```

### Conditions PersonnalisÃ©es

```php
// âœ… BON: Ã‰tendre AbstractCondition
final class StockCondition extends AbstractCondition
{
    public function __construct(
        private readonly int $productId,
        private readonly string $operator,
        private readonly int $quantity
    ) {}

    public function evaluate(RuleContext $context): bool
    {
        $stock = StockAvailable::getQuantityAvailableByProduct($this->productId);
        return $this->compare($stock, $this->operator, $this->quantity);
    }
}
```

### Actions PersonnalisÃ©es

```php
// âœ… BON: ImplÃ©menter ActionInterface
final class ApplyDiscountAction implements ActionInterface
{
    public function __construct(private readonly float $percent) {}

    public function execute(RuleContext $context): void
    {
        $cart = $context->getCart();
        // Appliquer la rÃ©duction...
    }
}
```

## ðŸš« Anti-patterns

```php
// âŒ Logique mÃ©tier dans les conditions
public function evaluate(RuleContext $context): bool
{
    // Ne pas faire de modification ici!
    $context->getCart()->updateQty(...);
    return true;
}

// âŒ Actions avec effets de bord non rÃ©versibles
public function execute(RuleContext $context): void
{
    Db::getInstance()->delete('orders', ...);  // Dangereux!
}
```

## ðŸ“ Exemple Complet

```php
class PromotionService
{
    private array $rules;

    public function __construct()
    {
        $this->rules = [
            // VIP: 10% si panier > 100â‚¬
            RuleBuilder::create('vip_discount')
                ->when(new CustomerCondition('group', '=', 3))
                ->and(new CartCondition('total', '>=', 100))
                ->then(new SetContextAction('discount_percent', 10))
                ->priority(20)
                ->build(),

            // Weekend: 5% pour tous
            RuleBuilder::create('weekend_promo')
                ->when(new DateCondition('is_weekend', '=', true))
                ->then(new SetContextAction('discount_percent', 5))
                ->priority(10)
                ->build(),

            // Nouveau client: livraison gratuite
            RuleBuilder::create('new_customer_shipping')
                ->when(new CustomerCondition('is_new', '=', true))
                ->then(new SetContextAction('free_shipping', true))
                ->priority(5)
                ->build(),
        ];
    }

    public function applyPromotions(): void
    {
        $engine = new RuleEngine();
        $context = RuleContext::fromCurrentCart();

        // Appliquer toutes les rÃ¨gles qui matchent
        $engine->executeAll($this->rules, $context);
    }
}
```
