---
description: API REST - Endpoints, Authentication, Responses
globs: ["src/Infrastructure/Api/**/*.php", "controllers/front/api*.php"]
alwaysApply: false
---

# API REST

## üîß Contr√¥leur API Symfony

### Structure de base

```php
<?php
// src/Infrastructure/Api/ItemApiController.php

declare(strict_types=1);

namespace ModuleStarter\Infrastructure\Api;

use ModuleStarter\Application\Service\ModuleStarterService;
use ModuleStarter\Domain\Exception\ItemNotFoundException;
use ModuleStarter\Domain\ValueObject\ItemId;
use ModuleStarter\Infrastructure\Adapter\ConfigurationAdapter;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;

/**
 * API REST pour les Items.
 *
 * @Route("/api/modulestarter", name="modulestarter_api_")
 */
class ItemApiController extends AbstractController
{
    public function __construct(
        private readonly ModuleStarterService $service,
        private readonly ConfigurationAdapter $config
    ) {
    }

    /**
     * Liste tous les items actifs.
     *
     * @Route("/items", name="items_list", methods={"GET"})
     */
    public function list(Request $request): JsonResponse
    {
        // Authentification
        if (!$this->isAuthenticated($request)) {
            return $this->errorResponse('Unauthorized', Response::HTTP_UNAUTHORIZED);
        }

        // Pagination
        $page = max(1, $request->query->getInt('page', 1));
        $perPage = min(100, max(1, $request->query->getInt('per_page', 10)));

        try {
            $items = $this->service->getActiveItems();
            $total = count($items);

            // Pagination manuelle
            $items = array_slice($items, ($page - 1) * $perPage, $perPage);

            return $this->successResponse([
                'items' => array_map(fn($item) => $this->serializeItem($item), $items),
                'meta' => [
                    'page' => $page,
                    'per_page' => $perPage,
                    'total' => $total,
                    'total_pages' => (int) ceil($total / $perPage),
                ],
            ]);
        } catch (\Exception $e) {
            return $this->errorResponse('Failed to fetch items', Response::HTTP_INTERNAL_SERVER_ERROR);
        }
    }

    /**
     * R√©cup√®re un item par ID.
     *
     * @Route("/items/{id}", name="items_get", methods={"GET"}, requirements={"id"="\d+"})
     */
    public function get(int $id, Request $request): JsonResponse
    {
        if (!$this->isAuthenticated($request)) {
            return $this->errorResponse('Unauthorized', Response::HTTP_UNAUTHORIZED);
        }

        try {
            $item = $this->service->getItem(new ItemId($id));

            if ($item === null) {
                return $this->errorResponse('Item not found', Response::HTTP_NOT_FOUND);
            }

            return $this->successResponse([
                'item' => $this->serializeItem($item),
            ]);
        } catch (\Exception $e) {
            return $this->errorResponse('Failed to fetch item', Response::HTTP_INTERNAL_SERVER_ERROR);
        }
    }

    /**
     * Cr√©e un nouvel item.
     *
     * @Route("/items", name="items_create", methods={"POST"})
     */
    public function create(Request $request): JsonResponse
    {
        if (!$this->isAuthenticated($request)) {
            return $this->errorResponse('Unauthorized', Response::HTTP_UNAUTHORIZED);
        }

        $data = $this->getJsonBody($request);

        // Validation
        $errors = $this->validateCreateData($data);
        if (!empty($errors)) {
            return $this->validationErrorResponse($errors);
        }

        try {
            $item = $this->service->create(
                $data['name'],
                $data['description'] ?? ''
            );

            return $this->successResponse(
                ['item' => $this->serializeItem($item)],
                Response::HTTP_CREATED
            );
        } catch (\InvalidArgumentException $e) {
            return $this->errorResponse($e->getMessage(), Response::HTTP_BAD_REQUEST);
        } catch (\Exception $e) {
            return $this->errorResponse('Failed to create item', Response::HTTP_INTERNAL_SERVER_ERROR);
        }
    }

    /**
     * Met √† jour un item.
     *
     * @Route("/items/{id}", name="items_update", methods={"PUT", "PATCH"})
     */
    public function update(int $id, Request $request): JsonResponse
    {
        if (!$this->isAuthenticated($request)) {
            return $this->errorResponse('Unauthorized', Response::HTTP_UNAUTHORIZED);
        }

        $data = $this->getJsonBody($request);

        try {
            $item = $this->service->update(new ItemId($id), $data);

            if ($item === null) {
                return $this->errorResponse('Item not found', Response::HTTP_NOT_FOUND);
            }

            return $this->successResponse([
                'item' => $this->serializeItem($item),
            ]);
        } catch (\InvalidArgumentException $e) {
            return $this->errorResponse($e->getMessage(), Response::HTTP_BAD_REQUEST);
        } catch (\Exception $e) {
            return $this->errorResponse('Failed to update item', Response::HTTP_INTERNAL_SERVER_ERROR);
        }
    }

    /**
     * Supprime un item.
     *
     * @Route("/items/{id}", name="items_delete", methods={"DELETE"})
     */
    public function delete(int $id, Request $request): JsonResponse
    {
        if (!$this->isAuthenticated($request)) {
            return $this->errorResponse('Unauthorized', Response::HTTP_UNAUTHORIZED);
        }

        try {
            $deleted = $this->service->delete(new ItemId($id));

            if (!$deleted) {
                return $this->errorResponse('Item not found', Response::HTTP_NOT_FOUND);
            }

            return new JsonResponse(null, Response::HTTP_NO_CONTENT);
        } catch (\Exception $e) {
            return $this->errorResponse('Failed to delete item', Response::HTTP_INTERNAL_SERVER_ERROR);
        }
    }

    // =========================================================================
    // HELPERS
    // =========================================================================

    /**
     * V√©rifie l'authentification API.
     */
    private function isAuthenticated(Request $request): bool
    {
        // M√©thode 1: API Key dans le header
        $apiKey = $request->headers->get('X-API-Key');
        $validKey = $this->config->get('MODULESTARTER_API_KEY');

        if ($apiKey !== null && $validKey !== null) {
            return hash_equals($validKey, $apiKey);
        }

        // M√©thode 2: Bearer Token
        $authHeader = $request->headers->get('Authorization');
        if ($authHeader !== null && str_starts_with($authHeader, 'Bearer ')) {
            $token = substr($authHeader, 7);
            return $this->validateBearerToken($token);
        }

        return false;
    }

    /**
     * Valide un Bearer token.
     */
    private function validateBearerToken(string $token): bool
    {
        // Impl√©menter la validation JWT ou autre
        $validToken = $this->config->get('MODULESTARTER_BEARER_TOKEN');
        return $validToken !== null && hash_equals($validToken, $token);
    }

    /**
     * Extrait le body JSON.
     */
    private function getJsonBody(Request $request): array
    {
        $content = $request->getContent();
        if (empty($content)) {
            return [];
        }

        $data = json_decode($content, true);
        if (json_last_error() !== JSON_ERROR_NONE) {
            throw new \InvalidArgumentException('Invalid JSON');
        }

        return $data;
    }

    /**
     * Valide les donn√©es de cr√©ation.
     */
    private function validateCreateData(array $data): array
    {
        $errors = [];

        if (empty($data['name'])) {
            $errors['name'] = 'Name is required';
        } elseif (strlen($data['name']) < 2) {
            $errors['name'] = 'Name must be at least 2 characters';
        } elseif (strlen($data['name']) > 255) {
            $errors['name'] = 'Name cannot exceed 255 characters';
        }

        if (isset($data['description']) && strlen($data['description']) > 1000) {
            $errors['description'] = 'Description cannot exceed 1000 characters';
        }

        return $errors;
    }

    /**
     * S√©rialise un item pour la r√©ponse JSON.
     */
    private function serializeItem($item): array
    {
        return [
            'id' => $item->getId()?->getValue(),
            'name' => $item->getName()->getValue(),
            'description' => $item->getDescription(),
            'active' => $item->isActive(),
            'position' => $item->getPosition(),
            'created_at' => $item->getCreatedAt()->format('c'),
            'updated_at' => $item->getUpdatedAt()->format('c'),
            '_links' => [
                'self' => [
                    'href' => '/api/modulestarter/items/' . $item->getId()?->getValue(),
                ],
            ],
        ];
    }

    /**
     * R√©ponse de succ√®s.
     */
    private function successResponse(array $data, int $status = Response::HTTP_OK): JsonResponse
    {
        return new JsonResponse([
            'success' => true,
            'data' => $data,
        ], $status);
    }

    /**
     * R√©ponse d'erreur.
     */
    private function errorResponse(string $message, int $status): JsonResponse
    {
        return new JsonResponse([
            'success' => false,
            'error' => [
                'code' => $status,
                'message' => $message,
            ],
        ], $status);
    }

    /**
     * R√©ponse d'erreur de validation.
     */
    private function validationErrorResponse(array $errors): JsonResponse
    {
        return new JsonResponse([
            'success' => false,
            'error' => [
                'code' => Response::HTTP_UNPROCESSABLE_ENTITY,
                'message' => 'Validation failed',
                'details' => $errors,
            ],
        ], Response::HTTP_UNPROCESSABLE_ENTITY);
    }
}
```

## üîê Authentification

### Configuration de l'API Key

```yaml
# config/services.yml

services:
    ModuleStarter\Infrastructure\Api\ItemApiController:
        arguments:
            $service: '@ModuleStarter\Application\Service\ModuleStarterService'
            $config: '@ModuleStarter\Infrastructure\Adapter\ConfigurationAdapter'
        tags:
            - { name: controller.service_arguments }
```

### G√©n√©ration d'une API Key

```php
// Dans la configuration du module
public function generateApiKey(): string
{
    $apiKey = bin2hex(random_bytes(32));

    Configuration::updateValue('MODULESTARTER_API_KEY', $apiKey);

    return $apiKey;
}
```

## üìã Routes API

```yaml
# config/routes/api.yml

# Pr√©fixe API
modulestarter_api:
    resource: '../src/Infrastructure/Api/'
    type: annotation
    prefix: /api/modulestarter
```

## üì® Format des R√©ponses

### Succ√®s - Liste

```json
{
    "success": true,
    "data": {
        "items": [
            {
                "id": 1,
                "name": "Item 1",
                "description": "Description",
                "active": true,
                "position": 0,
                "created_at": "2024-01-15T10:30:00+00:00",
                "updated_at": "2024-01-15T10:30:00+00:00",
                "_links": {
                    "self": {
                        "href": "/api/modulestarter/items/1"
                    }
                }
            }
        ],
        "meta": {
            "page": 1,
            "per_page": 10,
            "total": 25,
            "total_pages": 3
        }
    }
}
```

### Succ√®s - Cr√©ation (201)

```json
{
    "success": true,
    "data": {
        "item": {
            "id": 26,
            "name": "New Item",
            "description": "",
            "active": true,
            "position": 25,
            "created_at": "2024-01-16T14:22:00+00:00",
            "updated_at": "2024-01-16T14:22:00+00:00",
            "_links": {
                "self": {
                    "href": "/api/modulestarter/items/26"
                }
            }
        }
    }
}
```

### Erreur - Non trouv√© (404)

```json
{
    "success": false,
    "error": {
        "code": 404,
        "message": "Item not found"
    }
}
```

### Erreur - Validation (422)

```json
{
    "success": false,
    "error": {
        "code": 422,
        "message": "Validation failed",
        "details": {
            "name": "Name is required",
            "description": "Description cannot exceed 1000 characters"
        }
    }
}
```

### Erreur - Non autoris√© (401)

```json
{
    "success": false,
    "error": {
        "code": 401,
        "message": "Unauthorized"
    }
}
```

## üåê CORS (Cross-Origin Resource Sharing)

```php
// Event Subscriber pour les headers CORS
// src/Infrastructure/EventSubscriber/CorsSubscriber.php

declare(strict_types=1);

namespace ModuleStarter\Infrastructure\EventSubscriber;

use Symfony\Component\EventDispatcher\EventSubscriberInterface;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Event\RequestEvent;
use Symfony\Component\HttpKernel\Event\ResponseEvent;
use Symfony\Component\HttpKernel\KernelEvents;

class CorsSubscriber implements EventSubscriberInterface
{
    private const ALLOWED_ORIGINS = [
        'https://your-frontend.com',
        'http://localhost:3000',
    ];

    public static function getSubscribedEvents(): array
    {
        return [
            KernelEvents::REQUEST => ['onKernelRequest', 250],
            KernelEvents::RESPONSE => ['onKernelResponse', 0],
        ];
    }

    public function onKernelRequest(RequestEvent $event): void
    {
        if (!$event->isMainRequest()) {
            return;
        }

        $request = $event->getRequest();

        // G√©rer les requ√™tes OPTIONS (preflight)
        if ($request->getMethod() === 'OPTIONS' && $this->isApiRoute($request)) {
            $response = new Response();
            $response->setStatusCode(Response::HTTP_NO_CONTENT);
            $event->setResponse($response);
        }
    }

    public function onKernelResponse(ResponseEvent $event): void
    {
        if (!$event->isMainRequest()) {
            return;
        }

        $request = $event->getRequest();
        if (!$this->isApiRoute($request)) {
            return;
        }

        $response = $event->getResponse();
        $origin = $request->headers->get('Origin');

        if ($origin && in_array($origin, self::ALLOWED_ORIGINS, true)) {
            $response->headers->set('Access-Control-Allow-Origin', $origin);
            $response->headers->set('Access-Control-Allow-Methods', 'GET, POST, PUT, PATCH, DELETE, OPTIONS');
            $response->headers->set('Access-Control-Allow-Headers', 'Content-Type, X-API-Key, Authorization');
            $response->headers->set('Access-Control-Max-Age', '3600');
        }
    }

    private function isApiRoute(Request $request): bool
    {
        return str_starts_with($request->getPathInfo(), '/api/modulestarter');
    }
}
```

## üìä Rate Limiting

```php
// Simple rate limiting en m√©moire (pour production, utiliser Redis)
class RateLimiter
{
    private array $requests = [];
    private int $maxRequests = 100;
    private int $windowSeconds = 60;

    public function isAllowed(string $clientId): bool
    {
        $now = time();
        $windowStart = $now - $this->windowSeconds;

        // Nettoyer les anciennes entr√©es
        $this->requests[$clientId] = array_filter(
            $this->requests[$clientId] ?? [],
            fn($timestamp) => $timestamp > $windowStart
        );

        // V√©rifier la limite
        if (count($this->requests[$clientId]) >= $this->maxRequests) {
            return false;
        }

        // Enregistrer la requ√™te
        $this->requests[$clientId][] = $now;

        return true;
    }

    public function getRemainingRequests(string $clientId): int
    {
        return max(0, $this->maxRequests - count($this->requests[$clientId] ?? []));
    }
}
```

## üìù Documentation OpenAPI

```yaml
# openapi.yaml

openapi: 3.0.3
info:
    title: ModuleStarter API
    version: 1.0.0
    description: API REST pour le module PrestaShop ModuleStarter

servers:
    - url: /api/modulestarter
      description: Module API

security:
    - ApiKeyAuth: []

paths:
    /items:
        get:
            summary: Liste les items
            parameters:
                - name: page
                  in: query
                  schema:
                      type: integer
                      default: 1
                - name: per_page
                  in: query
                  schema:
                      type: integer
                      default: 10
                      maximum: 100
            responses:
                '200':
                    description: Liste des items
                    content:
                        application/json:
                            schema:
                                $ref: '#/components/schemas/ItemListResponse'
                '401':
                    $ref: '#/components/responses/Unauthorized'

        post:
            summary: Cr√©e un item
            requestBody:
                required: true
                content:
                    application/json:
                        schema:
                            $ref: '#/components/schemas/CreateItemRequest'
            responses:
                '201':
                    description: Item cr√©√©
                '422':
                    $ref: '#/components/responses/ValidationError'

components:
    securitySchemes:
        ApiKeyAuth:
            type: apiKey
            in: header
            name: X-API-Key

    schemas:
        Item:
            type: object
            properties:
                id:
                    type: integer
                name:
                    type: string
                description:
                    type: string
                active:
                    type: boolean
                created_at:
                    type: string
                    format: date-time

        CreateItemRequest:
            type: object
            required:
                - name
            properties:
                name:
                    type: string
                    minLength: 2
                    maxLength: 255
                description:
                    type: string
                    maxLength: 1000

    responses:
        Unauthorized:
            description: Non autoris√©
            content:
                application/json:
                    schema:
                        type: object
                        properties:
                            success:
                                type: boolean
                                example: false
                            error:
                                type: object
                                properties:
                                    code:
                                        type: integer
                                        example: 401
                                    message:
                                        type: string
                                        example: Unauthorized
```

## ‚úÖ Bonnes Pratiques API

1. **Versioning** - Pr√©voir le versioning `/api/v1/`
2. **Authentification** - API Key ou Bearer Token
3. **Validation** - Valider toutes les entr√©es
4. **Codes HTTP** - Utiliser les codes appropri√©s
5. **Format coh√©rent** - Structure `{success, data/error}`
6. **Pagination** - Pour les listes
7. **HATEOAS** - Liens vers les ressources li√©es
8. **Rate Limiting** - Prot√©ger contre l'abus
9. **CORS** - Configurer pour les clients autoris√©s
10. **Documentation** - OpenAPI/Swagger
